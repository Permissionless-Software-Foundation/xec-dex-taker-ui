!function(t){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).BchDexLib=t()}}((function(){return class{constructor(t={}){if(!t.wallet)throw new Error("Instance of minimal-slp-wallet must be passed as wallet property when instantiating the bch-dex-lib library.");if(this.wallet=t.wallet,!t.p2wdbRead)throw new Error("Instance of p2wdb must be passed as wallet property when instantiating the bch-dex-lib library.");if(this.p2wdbRead=t.p2wdbRead,!t.p2wdbWrite)throw new Error("Instance of p2wdb Write must be passed as p2wdbWrite property when instantiating the bch-dex-lib library.");this.p2wdbWrite=t.p2wdbWrite;const e={wallet:this.wallet,p2wdbRead:this.p2wdbRead,p2wdbWrite:this.p2wdbWrite};this.take=new class{constructor(t={}){if(!t.wallet)throw new Error("Instance of minimal-slp-wallet must be passed as wallet property when instantiating Take library.");if(this.wallet=t.wallet,!t.p2wdbRead)throw new Error("Instance of p2wdb Read must be passed as p2wdbRead property when instantiating Take library.");if(this.p2wdbRead=t.p2wdbRead,!t.p2wdbWrite)throw new Error("Instance of p2wdb Write must be passed as p2wdbWrite property when instantiating Take library.");this.p2wdbWrite=t.p2wdbWrite,this.util=new class{constructor(t={}){if(!t.wallet)throw new Error("Instance of minimal-slp-wallet must be passed as wallet property when instantiating bch-dex-util library.");if(this.wallet=t.wallet,!t.p2wdbRead)throw new Error("Instance of p2wdb Read must be passed as p2wdbRead property when instantiating bch-dex-util library.");this.p2wdbRead=t.p2wdbRead}async getEntryFromP2wdb(t){const e=await this.p2wdbRead.getByHash(t),a=e.value.data;let n;try{n=JSON.parse(a)}catch(o){n=e.value.data}return n}async validateUtxo(t,e){const a={tx_hash:t,tx_pos:e};return await this.wallet.utxoIsValid(a)}async getKeyPair(t=0){const e=this.wallet.walletInfo.mnemonic;if(!e)throw new Error("Wallet does not have a mnemonic. Can not generate a new key pair.");const a=await this.wallet.bchjs.Mnemonic.toSeed(e),n=this.wallet.bchjs.HDNode.fromSeed(a).derivePath("m/44'/245'/0'/0/"+t),o=this.wallet.bchjs.HDNode.toCashAddress(n);return console.log("Generating a new key pair for cashAddress: ",o),{cashAddress:o,wif:this.wallet.bchjs.HDNode.toWIF(n),hdIndex:t}}}(t)}async takeOffer(t){try{const e=await this.util.getEntryFromP2wdb(t);console.log("offerData: ",e);const a=e.data.utxoTxid,n=e.data.utxoVout;if(!await this.util.validateUtxo(a,n))throw new Error("Offer is not valid. UTXO has been spent.");const{hasEnoughFunds:o,bchAddr:s}=await this.ensureFunds(e);if(console.log("bchAddr: ",s),!o)throw new Error("This wallet does not have enough BCH to Counter the selected Offer.");const r=await this.moveBch(e);console.log("Counter Offer UTXO: ",r);const i=await this.generatePartialTx(e,r);console.log("partial tx hex: ",i);const d=await this.uploadCounterOffer(e,i,t);return console.log("Counter Offer uploaded to P2WDB with this CID: "+d.hash.hash),d}catch(e){throw console.error("Error in bch-dex-lib/take.js takeOffer(): ",e),e}}async uploadCounterOffer(t,e,a){console.log("uploadCounterOffer() offerData: "+JSON.stringify(t,null,2));const n=Object.assign({},t.data);return n.partialTxHex=e,delete n.p2wdbHash,delete n._id,n.offerHash=a,n.dataType="counter-offer",console.log("counterOfferData: "+JSON.stringify(n,null,2)),await this.p2wdbWrite.bchWallet.initialize(),await this.p2wdbWrite.postEntry(n,t.appId)}async generatePartialTx(t,e){const a=this.wallet.bchjs,n=new a.TransactionBuilder,o=await this.wallet.getTxData([t.data.utxoTxid]),s={txid:t.data.utxoTxid,vout:t.data.utxoVout,tokenId:t.data.tokenId,decimals:o[0].tokenDecimals,tokenQty:t.data.numTokens.toString()};let r;if(65===t.data.tokenType)r=a.SLP.NFT1.generateNFTChildSendOpReturn([s],t.data.numTokens.toString());else{if(1!==t.data.tokenType)throw new Error(`Unknown token type of ${t.data.tokenType}. Can not create Counter Offer.`);r=a.SLP.TokenType1.generateSendOpReturn([s],t.data.numTokens.toString())}const i=r.script;if(r.outputs>1)throw new Error("Partial purchase of Offers is not yet supported");const d=t.data.numTokens*parseInt(t.data.rateInBaseUnit);if(isNaN(d))throw new Error("Can not calculate needed sats");n.addInput(t.data.utxoTxid,t.data.utxoVout),n.addInput(e.txid,e.vout),n.addOutput(i,0);const l=this.wallet.walletInfo.legacyAddress;n.addOutput(l,546);const w=t.data.makerAddr;n.addOutput(w,d);const h=a.ECPair.fromWIF(e.wif);return n.sign(1,h,null,n.hashTypes.SIGHASH_ALL,e.sats),n.transaction.buildIncomplete().toHex()}async moveBch(t={},e=1){let a=t.data.numTokens*parseInt(t.data.rateInBaseUnit);if(isNaN(a))throw new Error("Could not calculate the amount of BCH to generate counter offer");a+=1e3;const n=await this.util.getKeyPair(e),o=[{address:n.cashAddress,amountSat:a}];await this.wallet.getUtxos();const s={txid:await this.wallet.send(o),vout:0,hdIndex:n.hdIndex,wif:n.wif,sats:a};return console.log(`BCH moved to ${n.cashAddress} with WIF ${n.wif}`),s}async ensureFunds(t){const{hasEnoughPsf:e,hasEnoughBch:a,bchAddr:n}=await this.p2wdbWrite.checkForSufficientFunds();if(!e&&!a)throw new Error("Wallet does not have enough BCH to write to the P2WDB.");let o=0;if(a&&(o=this.wallet.bchjs.BitcoinCash.toSatoshi(a)),!t.data.buyOrSell.includes("sell"))throw new Error("Buy offers are not supported yet.");{const e=t.data.numTokens*parseInt(t.data.rateInBaseUnit);if(isNaN(e))throw new Error("Could not calculate sats needed!");const a=await this.wallet.getBalance();console.log(`wallet balance: ${a}, sats needed: ${e}`);const n=e+5e3+o;if(n>a)throw new Error(`Wallet does not control enough BCH to purchase the tokens. It has ${a} sats, and needs ${n} sats.`)}return{hasEnoughFunds:!0,bchAddr:n}}}(e)}}}));